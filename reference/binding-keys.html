<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="When source consists of multiple datasets, binding keys allow to define what
relations occur between them.
When binding keys are defined, applying filtering on one dataset may result with
updating (filtering) the other ones.
For example having two tables in Source:
`book(book_id, author_id, title)`
`authors(author_id, name, surname)`
if we filter `authors` table, we way want to return only books for the selected authors.
With binding keys you could achieve it by providing `binding_keys` parameter for Source
as below:
  binding_keys = bind_keys(
    bind_key(
      update = data_key('books', 'author_id'),
      data_key('authors', 'author_id')
    )
  )


Or if we want to have two-way relation, just define another binding key:
  binding_keys = bind_keys(
    bind_key(
      update = data_key('books', 'author_id'),
      data_key('authors', 'author_id')
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )


As a result, whenever `books` or `authors` is filtered, the other table will be updated as well.
In order to understand binding keys concept we need to describe the following functions:
data_key Defines which table column should be used to describe relation.
bind_key Defines what relation occur between datasets.
bind_keys If needed, allows to define more than one relation.


- `data_key` - requires to provide two parameters:
dataset Name of the dataset existing in Source.
key Single character string or vector storing column names that are keys, which should be used to describe relation.
For example `data_key('books', 'author_id')`.
- `bind_key` - requires to provide two obligatory parameters
update Data key describing which table should be updated.
... Triggering data keys. One or more data keys describing on which dataset(s) the one in `update` is dependent.
The output of `bind_key` function is named binding key.
`bind_key` offers two extra parameters `post` and `activate`.
See below to learn how these parameters affect the final result.
- `bind_keys` - takes only binding keys as parameters
The function is used to define `binding_keys` parameter of Source.
Whenever you define a single or more binding keys wrap them with `bind_keys`.
It's worth to mention that binding key describes inner-join like relation.
That means the updated table's key is intersection of its key and keys of
remaining tables defined in binding key.
Another important note is that binding keys order matters - binding is performed
sequentially, taking into account returned data from the previous bindings.
You may achieve more flexibility with two parameters:
activate
post


Active tables and `activate` parameter
We name a table `active` that is attached to at least one active filter (in a step).
When having defined binding key, e.g.
  bind_key(
    update = data_key('books', 'author_id'),
    data_key('authors', 'author_id')
  )
the key is taken into account only when at least one triggering table is active.
So in the above example binding key will update `books` only when `authors` was
filtered (more precisely when any filter attached to `authors` is active).
The `activate = TRUE` parameter setup, lets us to decide whether `update` table
should be marked as active as well when the binding finish.
This allows to build dependency chains between table.
Let's explain this in the below example. Having defined another table in Source
`borrowed(book_id, user_id, date)` and binding key:
  bind_keys(
    bind_key(
      update = data_key('books', 'book_id'),
      data_key('borrowed', 'book_id')
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )
Let's consider the case when table `borrowed` is active, `books` is not.
What happens during the binding process:
1. Based on the first binding key, active `borrowed` triggers this one.
2. As a result `books` is modified.
What should happen with the second binding key.
We have two options:
1. `books` could be marked as active as well so it triggers the second key.
2. `books` could remain inactive so the second key is not triggered.
It will be triggered only when `books` is directly filtered (activated).
You may choose between 1 and 2 with `activate = TRUE` (the default)  and `activate = FALSE`
respectively.
So in the above example (because `activate = TRUE` by default) the authors table
will also be modified by the second binding key.
To turn off this behavior we just need to:
  bind_keys(
    bind_key(
      update = data_key('books', 'book_id'),
      data_key('borrowed', 'book_id'),
      activate = TRUE
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )


Bind filtered on unfiltered data - `post` parameter
Let's tart with the below binding key example:
  bind_keys(
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )


Let's assume `authors` table is filtered and we apply filtering for `books` table.
We may want to achieve one of the two results:
1. `authors` filters should be taken into account while binding.
2. we should take unfiltered `authors` an apply binding based on `books` choices.
We can achieve 1 and 2 with defining `post = TRUE` (the default) and `post = FALSE` respectively.
So the following setup:
  bind_keys(
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id'),
      post = FALSE
    )
  )


Whenever `books` is changed will result with filtering only the authors that written selected books -
no extra `authors` filters will be applied.
There might be the situation when table was already bound but there is another
one binding key to be executed on the same table.
In this case `post = FALSE` case will remain the same - unfiltered table will be taken.
More to that filtering and previous binding related to this table will be ignored.
In case of `post = TRUE` the previously bound table will be updated."><title>Describe data relations with binding keys — binding-keys • cohortBuilder</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Describe data relations with binding keys — binding-keys"><meta property="og:description" content="When source consists of multiple datasets, binding keys allow to define what
relations occur between them.
When binding keys are defined, applying filtering on one dataset may result with
updating (filtering) the other ones.
For example having two tables in Source:
`book(book_id, author_id, title)`
`authors(author_id, name, surname)`
if we filter `authors` table, we way want to return only books for the selected authors.
With binding keys you could achieve it by providing `binding_keys` parameter for Source
as below:
  binding_keys = bind_keys(
    bind_key(
      update = data_key('books', 'author_id'),
      data_key('authors', 'author_id')
    )
  )


Or if we want to have two-way relation, just define another binding key:
  binding_keys = bind_keys(
    bind_key(
      update = data_key('books', 'author_id'),
      data_key('authors', 'author_id')
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )


As a result, whenever `books` or `authors` is filtered, the other table will be updated as well.
In order to understand binding keys concept we need to describe the following functions:
data_key Defines which table column should be used to describe relation.
bind_key Defines what relation occur between datasets.
bind_keys If needed, allows to define more than one relation.


- `data_key` - requires to provide two parameters:
dataset Name of the dataset existing in Source.
key Single character string or vector storing column names that are keys, which should be used to describe relation.
For example `data_key('books', 'author_id')`.
- `bind_key` - requires to provide two obligatory parameters
update Data key describing which table should be updated.
... Triggering data keys. One or more data keys describing on which dataset(s) the one in `update` is dependent.
The output of `bind_key` function is named binding key.
`bind_key` offers two extra parameters `post` and `activate`.
See below to learn how these parameters affect the final result.
- `bind_keys` - takes only binding keys as parameters
The function is used to define `binding_keys` parameter of Source.
Whenever you define a single or more binding keys wrap them with `bind_keys`.
It's worth to mention that binding key describes inner-join like relation.
That means the updated table's key is intersection of its key and keys of
remaining tables defined in binding key.
Another important note is that binding keys order matters - binding is performed
sequentially, taking into account returned data from the previous bindings.
You may achieve more flexibility with two parameters:
activate
post


Active tables and `activate` parameter
We name a table `active` that is attached to at least one active filter (in a step).
When having defined binding key, e.g.
  bind_key(
    update = data_key('books', 'author_id'),
    data_key('authors', 'author_id')
  )
the key is taken into account only when at least one triggering table is active.
So in the above example binding key will update `books` only when `authors` was
filtered (more precisely when any filter attached to `authors` is active).
The `activate = TRUE` parameter setup, lets us to decide whether `update` table
should be marked as active as well when the binding finish.
This allows to build dependency chains between table.
Let's explain this in the below example. Having defined another table in Source
`borrowed(book_id, user_id, date)` and binding key:
  bind_keys(
    bind_key(
      update = data_key('books', 'book_id'),
      data_key('borrowed', 'book_id')
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )
Let's consider the case when table `borrowed` is active, `books` is not.
What happens during the binding process:
1. Based on the first binding key, active `borrowed` triggers this one.
2. As a result `books` is modified.
What should happen with the second binding key.
We have two options:
1. `books` could be marked as active as well so it triggers the second key.
2. `books` could remain inactive so the second key is not triggered.
It will be triggered only when `books` is directly filtered (activated).
You may choose between 1 and 2 with `activate = TRUE` (the default)  and `activate = FALSE`
respectively.
So in the above example (because `activate = TRUE` by default) the authors table
will also be modified by the second binding key.
To turn off this behavior we just need to:
  bind_keys(
    bind_key(
      update = data_key('books', 'book_id'),
      data_key('borrowed', 'book_id'),
      activate = TRUE
    ),
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )


Bind filtered on unfiltered data - `post` parameter
Let's tart with the below binding key example:
  bind_keys(
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id')
    )
  )


Let's assume `authors` table is filtered and we apply filtering for `books` table.
We may want to achieve one of the two results:
1. `authors` filters should be taken into account while binding.
2. we should take unfiltered `authors` an apply binding based on `books` choices.
We can achieve 1 and 2 with defining `post = TRUE` (the default) and `post = FALSE` respectively.
So the following setup:
  bind_keys(
    bind_key(
      update = data_key('authors', 'author_id'),
      data_key('books', 'author_id'),
      post = FALSE
    )
  )


Whenever `books` is changed will result with filtering only the authors that written selected books -
no extra `authors` filters will be applied.
There might be the situation when table was already bound but there is another
one binding key to be executed on the same table.
In this case `post = FALSE` case will remain the same - unfiltered table will be taken.
More to that filtering and previous binding related to this table will be ignored.
In case of `post = TRUE` the previously bound table will be updated."><meta property="og:image" content="https://r-world-devs.github.io/cohortBuilder/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">cohortBuilder</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item">
  <a class="nav-link" href="../articles/cohortBuilder.html">
    <span class="fa fa fa fa-thumbs-o-up"></span>
     
    Get started
  </a>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">
    <span class="fa fa fa fa-file-code-o"></span>
     
    Functions
  </a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown--articles">
    <span class="fa fa fa fa-thumbs-o-up"></span>
     
    Articles
  </a>
  <div class="dropdown-menu" aria-labelledby="dropdown--articles">
    <a class="dropdown-item" href="../articles/managing-cohort.html">Managing Cohort Object</a>
    <a class="dropdown-item" href="../articles/cohort-configuration.html">Variants for Cohort Configuration</a>
    <a class="dropdown-item" href="../articles/binding-keys.html">Specifying data relations with Binding Keys</a>
    <a class="dropdown-item" href="../articles/custom-filters.html">Implementing custom filters</a>
    <a class="dropdown-item" href="../articles/custom-extensions.html">Writing custom extensions</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">
    <span class="fa fa fa fa-newspaper-o"></span>
     
    News
  </a>
</li>
<li class="nav-item">
  <a class="nav-link" href="https://r-world-devs.github.io/cohortBuilder/issues">
    <span class="fa fa fa fa-ambulance"></span>
     
    Issues
  </a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/r-world-devs/cohortBuilder/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Describe data relations with binding keys</h1>
      <small class="dont-index">Source: <a href="https://github.com/r-world-devs/cohortBuilder/blob/HEAD/R/bind_keys.R" class="external-link"><code>R/bind_keys.R</code></a></small>
      <div class="d-none name"><code>binding-keys.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>When source consists of multiple datasets, binding keys allow to define what
relations occur between them.
When binding keys are defined, applying filtering on one dataset may result with
updating (filtering) the other ones.</p>
<p>For example having two tables in Source:
`book(book_id, author_id, title)`
`authors(author_id, name, surname)`
if we filter `authors` table, we way want to return only books for the selected authors.</p>
<p>With binding keys you could achieve it by providing `binding_keys` parameter for Source
as below:</p><div class="sourceCode"><pre><code><span class="va">binding_keys</span> <span class="op">=</span> <span class="fu"><a href="../reference/binding-keys.html">bind_keys</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>
    <span class="op">)</span>
  <span class="op">)</span></code></pre></div>

<p>Or if we want to have two-way relation, just define another binding key:</p><div class="sourceCode"><pre><code><span class="va">binding_keys</span> <span class="op">=</span> <span class="fu"><a href="../reference/binding-keys.html">bind_keys</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>
    <span class="op">)</span>,
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>
    <span class="op">)</span>
  <span class="op">)</span></code></pre></div>

<p>As a result, whenever `books` or `authors` is filtered, the other table will be updated as well.</p>
<p>In order to understand binding keys concept we need to describe the following functions:</p><ul><li><p><a href="data_key.html">data_key</a> Defines which table column should be used to describe relation.</p></li>
<li><p>bind_key Defines what relation occur between datasets.</p></li>
<li><p>bind_keys If needed, allows to define more than one relation.</p></li>
</ul><p>- `data_key` - requires to provide two parameters:</p><ul><li><p>dataset Name of the dataset existing in Source.</p></li>
<li><p>key Single character string or vector storing column names that are keys, which should be used to describe relation.</p></li>
</ul><p>For example `data_key('books', 'author_id')`.</p>
<p>- `bind_key` - requires to provide two obligatory parameters</p><ul><li><p>update Data key describing which table should be updated.</p></li>
<li><p>... <strong>Triggering data keys</strong>. One or more data keys describing on which dataset(s) the one in `update` is dependent.</p></li>
</ul><p>The output of `bind_key` function is named <strong>binding key</strong>.
`bind_key` offers two extra parameters `post` and `activate`.
See below to learn how these parameters affect the final result.</p>
<p>- `bind_keys` - takes only binding keys as parameters
The function is used to define `binding_keys` parameter of Source.
Whenever you define a single or more binding keys wrap them with `bind_keys`.</p>
<p>It's worth to mention that binding key describes inner-join like relation.
That means the updated table's key is intersection of its key and keys of
remaining tables defined in binding key.</p>
<p>Another important note is that binding keys order matters - binding is performed
sequentially, taking into account returned data from the previous bindings.</p>
<p>You may achieve more flexibility with two parameters:</p><ul><li><p>activate</p></li>
<li><p>post</p></li>
</ul><p><strong>Active tables and `activate` parameter</strong></p>
<p>We name a table `active` that is attached to at least one active filter (in a step).</p>
<p>When having defined binding key, e.g.</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
    update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
    <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>
  <span class="op">)</span></code></pre></div><p>the key is taken into account only when at least one triggering table is active.
So in the above example binding key will update `books` only when `authors` was
filtered (more precisely when any filter attached to `authors` is active).</p>
<p>The `activate = TRUE` parameter setup, lets us to decide whether `update` table
should be marked as active as well when the binding finish.
This allows to build dependency chains between table.</p>
<p>Let's explain this in the below example. Having defined another table in Source
`borrowed(book_id, user_id, date)` and binding key:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/binding-keys.html">bind_keys</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'book_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'borrowed'</span>, <span class="st">'book_id'</span><span class="op">)</span>
    <span class="op">)</span>,
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>
    <span class="op">)</span>
  <span class="op">)</span></code></pre></div><p>Let's consider the case when table `borrowed` is active, `books` is not.
What happens during the binding process:
1. Based on the first binding key, active `borrowed` triggers this one.
2. As a result `books` is modified.</p>
<p>What should happen with the second binding key.
We have two options:
1. `books` could be marked as active as well so it triggers the second key.
2. `books` could remain inactive so the second key is not triggered.
It will be triggered only when `books` is directly filtered (activated).</p>
<p>You may choose between 1 and 2 with `activate = TRUE` (the default)  and `activate = FALSE`
respectively.</p>
<p>So in the above example (because `activate = TRUE` by default) the authors table
will also be modified by the second binding key.</p>
<p>To turn off this behavior we just need to:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/binding-keys.html">bind_keys</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'book_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'borrowed'</span>, <span class="st">'book_id'</span><span class="op">)</span>,
      activate <span class="op">=</span> <span class="cn">TRUE</span>
    <span class="op">)</span>,
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>
    <span class="op">)</span>
  <span class="op">)</span></code></pre></div>

<p><strong>Bind filtered on unfiltered data - `post` parameter</strong></p>
<p>Let's tart with the below binding key example:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/binding-keys.html">bind_keys</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>
    <span class="op">)</span>
  <span class="op">)</span></code></pre></div>

<p>Let's assume `authors` table is filtered and we apply filtering for `books` table.
We may want to achieve one of the two results:
1. `authors` filters should be taken into account while binding.
2. we should take unfiltered `authors` an apply binding based on `books` choices.</p>
<p>We can achieve 1 and 2 with defining `post = TRUE` (the default) and `post = FALSE` respectively.</p>
<p>So the following setup:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/binding-keys.html">bind_keys</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/binding-keys.html">bind_key</a></span><span class="op">(</span>
      update <span class="op">=</span> <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'authors'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      <span class="fu"><a href="../reference/data_key.html">data_key</a></span><span class="op">(</span><span class="st">'books'</span>, <span class="st">'author_id'</span><span class="op">)</span>,
      post <span class="op">=</span> <span class="cn">FALSE</span>
    <span class="op">)</span>
  <span class="op">)</span></code></pre></div>

<p>Whenever `books` is changed will result with filtering only the authors that written selected books -
no extra `authors` filters will be applied.</p>
<p>There might be the situation when table was already bound but there is another
one binding key to be executed on the same table.</p>
<p>In this case `post = FALSE` case will remain the same - unfiltered table will be taken.
More to that filtering and previous binding related to this table will be ignored.
In case of `post = TRUE` the previously bound table will be updated.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="fu">bind_keys</span><span class="op">(</span><span class="va">...</span><span class="op">)</span>

<span class="fu">bind_key</span><span class="op">(</span><span class="va">update</span>, <span class="va">...</span>, post <span class="op">=</span> <span class="cn">TRUE</span>, activate <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>...</dt>
<dd><p>In case of `bind_keys`, binding keys created with `bind_key`.
In case of `bind_key`, data keys describing triggering tables.</p></dd>
<dt>update</dt>
<dd><p>Data key describing table to update.</p></dd>
<dt>post</dt>
<dd><p>Update filtered or unfiltered table.</p></dd>
<dt>activate</dt>
<dd><p>Mark bound table as active.</p></dd>
</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>List of class `bind_keys` storing `bind_key` class objects (`bind_keys`) or
  `bind_key` class list (`bind_key`).</p>
    </div>

  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Krystian Igras.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.2.</p>
</div>

    </footer></div>

  

  

  </body></html>

